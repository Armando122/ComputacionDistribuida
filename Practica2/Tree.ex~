defmodule Tree do

  def new(n) do
    create_tree(Enum.map(1..n, fn _ -> spawn(fn -> loop() end) end), %{}, 0)
  end

  defp loop() do
    receive do
      {:broadcast, tree, i, caller} ->
	left = Map.get(tree, (2*i+1), nil)
	right = Map.get(tree, (2*i+2), nil)
	case {left, right} do
	  {nil, nil} -> send(caller, {self(), :ok})
	  {l, nil} -> send(l, {:broadcast, tree, 2*i+1, caller})
	  {l, r} ->
	    send(l, {:broadcast, tree, 2*i+1, caller})
	    send(r, {:broadcast, tree, 2*i+2, caller})
	end
      {:convergecast, tree, i, caller} ->
	case i do
	  0 -> send(caller, {self(), :ok})
	  x -> send(Map.get(tree, div(x, 2)), {:convergecast, tree, div(x, 2), caller})
	end
    end
  end

  defp create_tree([], tree, _) do
    tree
  end

  defp create_tree([pid | l], tree, pos) do
    create_tree(l, Map.put(tree, pos, pid), (pos+1))
  end

  def broadcast(tree, n) do
    leafs = div(n+1, 2)
    send(Map.get(tree, 0), {:broadcast, tree, 0, self()})
    Enum.map(1..leafs, fn _ ->
      receive do
	{sender, status} -> {sender, status}
      end
    end)
  end

  def convergecast(tree, n) do
    leafs = div(n+1, 2)
    Enum.each((leafs)..(n-1), fn leaf ->
      send(Map.get(tree, leaf), {:convergecast, tree, leaf, self()})
    end)
    receive do
      {sender, status} -> {sender, status}
    end
  end
  
end
